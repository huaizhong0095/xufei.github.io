使用JavaScript创建双人对战象棋程序
====

这篇文章的主要目的是介绍使用AngularJS构建SPA程序的分析过程。

#1. 怎样划分模块

##1.1. 面向对象

面向对象可以算是老生常谈了，在现代软件开发中，它是个主流的选择，相对于面向过程，有一些改进。

假设我们是上帝，要创造世界，因为这个过程太过复杂，无从入手，所以先从一件简单的事情看起。现在我们要设计一个方法，用于描述狼吃羊这个事情，某只狼吃了某只羊，你可以面向过程地吃，eat(狼A, 羊A)，也可以面向对象地吃，狼A.eat(羊A)。差别在哪里？只是写法有点变化。

好，那么我们帮上帝模拟整个生物界，这里面很多东西可以吃，大鱼吃小鱼，小鱼吃虾米，吃不吃皮，吐不吐骨头，这个时候再来修改这个eat函数，复杂吗？eat里面要判断很多东西，假如上帝很勤劳，所有代码都自己设计，那没关系，没太大区别，判断就判断呗。

假设上帝没足够精力来管理整个东西了，雇了一群天使来协助设计，每个人都来修改这个eat函数，当然可以拆分，wolfEatSheep(), tigerEatWolf()，然后在eat里面判断参数来分别调用，把函数分下去让每个人做，可以。

动物不光要做吃这个事情，要能跑能跳，会说会叫，又多了一堆函数，每个里面都这么判断，相当相当的烦。怎么办？我们来面向对象一下。

现在开始按照动物拆分，100个天使，每个天使创造一种动物。创造哪种动物，就站在哪种动物的角度考虑问题，我吃的时候怎么吃，跑的时候怎么跑，都跟别人无关，这么一来，每个人就专注多了。每个动物只关注我要怎么才能活着，不必站在上帝的角度考虑问题。这个过程，是类的划分过程，也就是封装的过程。

这时候，上帝觉得自然界光有动物是不行的，还要有植物，刚才说的这些都是动物，植物的特点跟动物有很大区别。假设你是上帝，为每种生物安排衣食住行，那是相当复杂的。偷懒吧，上帝说，植物们，你们自己生长吧，动物们，你们吃喝玩乐吧，假如能达到这个效果，那很省事。

上帝用一个循环来遍历所有动物，让他们吃喝玩乐，用另外一个循环让植物欣欣向荣。动物跟植物为什么要区别对待？因为它们不是同样的东西，能做的事情不同。所有动物派生于动物这个基础类型，从动物这个种类下，又分出各种纲，各种目，各种属。狮子是哺乳动物，猴子也是，但是狮子是猫科动物，猴子是灵长动物，这就构成了一个倒着的树状体系，一层一层形成继承关系。哺乳动物会喂奶，那么所有继承自哺乳动物的，都自动拥有这个特征。整个这一切，构成了继承链。

假设有一天由于变异出现了新物种，不必劳烦上帝关照，只要鉴别一下它属于什么类型，就知道能做什么事了，它的一举一动，都必然拥有它所继承的种类的特征。

这样就能描述生物界了吗？不，还有那么一些怪胎的存在。你认为哺乳动物都不会飞，那就错了，因为蝙蝠会飞。蝙蝠会飞是它自身的特性，并非继承自哺乳动物，但是“飞”这个动作，却非蝙蝠独有。如果把“飞”定义成接口，那就很美好了，蝙蝠实现了它的飞行接口，虽然内部实现跟鸟类有所不同，而且这并不影响它的哺乳动物特性。

总之，是否面向对象只是思维方式的不同。做一个软件，面向对象也能做，不面向对象也能做。我的观点，如果关注可维护性和协作性，从目前的角度，面向对象是很好的选择，它很自然，很优雅，优雅得只要打一个“.”，你就能想起来什么事能做，什么事不能做。

##1.2. 模型的职责划分

面向对象的一个基本原则是分而治之（Divide and Conquer），这种方法论提倡将程序模块化，各模块实现单独的功能，在统一的管理下协同工作，构成整个系统。

在具体实施的时候，又有两种倾向：将功能高度集中于主控制模块；将功能下放到各部件。这两种做法都有很高的可行性，也分别有大量支持者。我觉得在一些程度上，后者更贴近人类的思维方式，更适合用人性化的观念来解释。

将两种类型的程序对应到生物集群，第一种相当于一个蚁群，第二个相当于人群。蚁群的特点是，个体能够完成的事务非常有限，但是因为在一个非常强有力的统治者蚁后的控制下，它们能够协同工作，统一调度，完成不可想象的事件。人群的特点是，每个人都可以独立思考，能够理解别人的指令，并且根据这些指令做到力所能及的事情。作为人群的统治者，他的智慧不需要比其他人的高太多，只需要从宏观上来把握一些事情即可。

从系统的实现来说，第一种方式难度很高。完成单个蚂蚁（小模块）的功能并不复杂，创建大量的蚂蚁也只不过是需要的时间多一点，但是，当开始设计蚁后（总控模块）的时候，噩梦开始了，整个调度算法实在是一件令人头疼的事情。对于比较复杂一点的系统，让一个人去设计这个模块简直是不可思议，但是如果由多个人共同完成这个模块，又面临着互相理解的问题，每个人的思路都不相同，在努力协作的过程中，大量的时间被浪费在交流和意见的统一上。与此同时，制作蚂蚁的程序员日益烦躁，觉得自己的工作没有难度，无聊，士气低下……

换一种思路，从人类管理的角度来看问题。假设有一支庞大的军队（假设是一个集团军），司令官需要他的士兵列队，我们来为这个系统设计调度算法。先假设所有士兵跟蚂蚁一样笨，他们只能明白“站到司令部大门往东50米，往北100米的地方”这样的简单指令，请同情一下这位司令官，他不得不为每个士兵来指定一个位置，并且不得不研究列队的规则，他需要整天忙碌来完成这样一个庞大的任务（而且还不一定能完成）。他叹息道：哦，上帝……

让我们设法来减轻他的烦恼吧，目标是让每个人都主动参与这个事件，不再那么被动，大家都努力完成自己力所能及的工作。于是我们授权各级指挥官让他自己的士兵列队，这样一来，司令官的工作简单多了，他发布命令：各位军长请注意，我命令你们列队，按照番号顺序，分布到司令部门口的空地上（假设这个空地足够大，姑且认为能够容纳整个集团军），各军之间保持50米间隔。

接到命令以后，军长们开始忙碌，而司令官先生已经可以搬一把椅子坐到电话机旁，等待列队完毕的报告了。同样，军长要做的事情，也就是告诉属下的各位师长，让他们按照番号顺序列队，就这样，命令被传递到最下面一级。班长大喊：伙计们，按照个头排成一列，矮的在前面，高的在后面，前后间隔一米！于是，所有人站到了他应该站的位置，望着在短时间内迅速列队的整个集团军，司令官太满意了。

我们发现了什么？很显然，下放权力的方式要省事得多，更关键的是，它使得每个人都做一定的事情，但是又不成为负担。在设计者思路清晰化的同时，负责为系统每个部分编写代码的人员也更容易享受到编程的乐趣，就算是最低层的程序员也有了发挥自己才能、用自己的思路去影响系统的机会，而且，系统集成的过程将变得更加简单。

对于一名软件设计师来说，他的思想决定了他所设计出来的软件结构，将自己的灵魂注入到冰冷的代码中，这是一种艺术。然而，不同的人有不同的风格，设计者对于世界的认知方式不同，他们对于同样的需求，可能采用的设计方式也多种多样。

#2. AngularJS应用程序的几个组成部分

一个AngularJS模块可以由这么几个部分组成，

##2.1. 配置数据

模块要运行，有时候会有一些配置工作，在AngularJS里，这部分工作可以通过模块的config方法来进行。

##2.2. 服务

Web应用程序通常需要跟服务端打交道，比如通过AJAX调用某个RESTful服务，或者SOAP WebService，或者通过WebSocket进行实时交互，这部分都可以定义成服务。在AngularJS里面，服务通过模块的service方法来定义。

##2.3. 工厂

有时候，我们需要在一些实体上定义方法，比如校验订单的正确性，比如统计购物车的总金额，这时候可以把它们定义成工厂。在AngularJS里面，工厂通过模块的factory方法来定义。

##2.4. 控制器

有了服务和工厂之后，就可以做一些更贴近界面的工作了，

##2.5. 指令

有时候我们的界面并不总是那么简单，我们希望让界面编写者不那么直接去面对太多细节，需要把这些细节的实现隐藏到某个地方，这就有了指令。在AngularJS里面，指令通过模块的directive方法来定义。

#3. 怎么设计我们的象棋程序

##3.1. 模块的划分

按照我们在第一部分提到的思路，棋子应当是要承担一些职责的，那么，哪些事情适合交给棋子来做呢？

我们把走棋的这个过程分解，这里有四个部分：

- 判断我有没有可能出现在那个位置，比如说，象不能过河，老将和卫士不能出九宫格。
- 判断目标位置有没有己方棋子，如果有，也过不去。
- 判断能否直接到达目标位置，比如说，马腿是否被挡着了？象眼是否被塞着了？
- 移动过去，如果有对方棋子，吃掉它。

从第一步来看，这个过程不依赖于其他任何东西，每个棋子都应当能够牢记自己能去什么地方，不能去什么地方，只要你给它一个棋盘坐标，它自己是可以知道能不能去的。所以，这个职责我们放给棋子。

再看第二步，这个我们怎么判断呢？假设我们是一个士兵，在平原上打仗，我想知道前面山顶有没有人，怎么办？看了很多电影的我们表示，很好办。“总部总部，请侦察对面山顶。”所以，这个过程我们可以看到，检索目标位置不是棋子自身的职责，他只是调用了某个别的东西（己方司令部），得到了结果。

下面是第三步，这里面有可能不需要依赖于其他模块，也可能要依赖，怎么解释呢？比如说卫士，他走路只看距离，如果是他的合法可达位置，并且和当前位置距离的平方为1+1=2，那就可以直接过去，不需要依赖任何外部模块。但是如果是马，要先看距离的平方是不是1+4=5，然后再找马腿的位置，再去看那个位置有没有棋子。所以这种情况下，就要依赖外部模块。

第四步很简单，过去的时候发个通知给司令部，我换地方了！

于是，我们得出结论，棋子的职责应该是这些：判断自己是否可能出现在某位置；判断自己能否到达某位置；移动到某位置。


现在我们来考虑，谁来提供这个查询的服务，承担司令部的这些职责，很明显，这是一个全局唯一的东西，应当被设计成单例，在AngularJS中，这样的东西应当被定义为服务，所以我们有了一个chessService。

这个服务也有了我们需要的第一个方法：根据当前颜色，查询某个坐标是否有友军。既然我们可以查询，那应该需要有个地方存放当前棋局，而服务在整个AngularJS体系中已经位于最下层了，所以它除了依赖别的服务，不应当依赖其他类型的模块。这个象棋程序并不复杂，所以我们不打算再创建其他服务了，棋局就存放在这个服务内部，对外提供一系列方法供使用。

简单地考虑一下，我们的棋局应当能够：

- 初始化。初始化方法做的是把棋局恢复成初始状态，每次重新开局之前，我们可以这么做一下。

- 走棋。走棋是把给出的棋子移动到指定位置，如果目标位置没有别的棋子，只做移动，否则还要把对方杀死。走棋之前有一些判断条件，我们也把它们列出来。

* 列出某棋子的可达范围。这其实是一个辅助功能，当用户点击某棋子的时候，界面上能够标示出所有该棋子的可到达位置，便于用户选择，当用户选择其中某一个的时候，把棋子移动过去。

- 判断是否终局。每一步棋走完，我们都需要看一下是否有一方获胜，如果有，本局应当终止。

- 求和

#4. 代码实现

#4.1. 总体结构

#4.2. 具体实现



#5. 可能的改进

上面我们实现了一个可以在单机下双人对战的象棋程序，运行得还不错，但是我们想要给它一些增强，应当如何去做呢？

一个很典型的增强是，既然我们都做了单机的对战了，是不是可以搞一个服务端，变成联机的对战呢？当然可以，要做这个，我们唯一需要改动的代码是chessService，把初始化，走棋这些都改造成调用服务端的方法即可，从这里我们也可以看到如果代码进行了合理的分层，当需要改进的时候，对原代码改动有多么容易。

从另外一个方面看，如果我们不做服务端，而是想要本机开多个棋局，怎么办呢？我们来尝试一下。

在我们的考虑中，这应该非常容易，因为只需要多创建一个界面块，给它另外一个控制器实例就可以了，是不是这样呢？

很遗憾，事实有一些出入。原因在哪里？注意到我们的棋局存放在什么地方？在chessService里，它是用service定义的，这种方式决定了它是个单例，所以所有本机的期盼共享同一份棋局，为了避免这个问题，我们来把chessService改变一下，定义成factory。


#6. 总结

2004年，我花两天时间，用JavaScript和VML创建了一个单机双人象棋，并且作了简短的分析。在那个时代，没有AngularJS，没有BackBone，没有所有这些前端MV*框架。甚至没有jQuery，没有prototype，没有mootools，因此没有什么可借鉴的模块划分方式。我只好用很原始的办法，做了一种伪继承，实际是组合，来实现棋子和棋局之间的关系。

现在是2013年，9年过去了，Web的世界早已不是过去的样子，开发方式发生了翻天覆地的变化，我们有了Gmail，有了google docs等等把Web技术应用到极致的优秀产品，有了asm.js、pdf.js等等让我们目瞪口呆的技术，更催生了各种MV*框架的兴起。

严格来说，使用AngularJS来做这个例子，并不是很好的选择，因为这个例子没有发挥它的特长，只用来演示了一下模块化和分层的过程，没有用到数据绑定，没有用到DOM模板，因此这一切如果使用BackBone来做，可能做得更漂亮。

另外一个方面，我们看到VML已经彻底衰落了，各种基于SVG和Canvas的绘图技术取代了它，因此在本例中，我们也与时俱进，改用SVG来绘制棋盘和棋子。